\chapter{Curiosity Marsbot}
\begin{center}
    \textbf{Sinh viên thực hiện: Ngô Mạnh Hùng - 20226083}
\end{center}
\section{Đề bài}
Xe tự hành Curiosity Marsbot chạy trên sao Hỏa, được vận hành từ xa bởi các lập trình viên trên Trái Đất.
Bằng cách gửi đi các mã điều khiển từ một bàn phím ma trận, lập trình viên điều khiển quá trình di chuyển
của Marbot như sau:
\begin{description}
    \item[1b4] Marsbot bắt đầu chuyển động.
    \item[c68] Marsbot đứng im.
    \item[444] Rẽ trái 90 độ so với phương chuyển động gần nhất.
    \item[666] Rẽ phải 90 độ so với phương chuyển động gần nhất.
    \item[dad] Bắt đầu để lại vết trên đường.
    \item[cbc] Chấm dứt để lại vết trên đường.
    \item[999] Tự động đi theo lộ trình ngược lại. Không vẽ vết, không nhận mã khác cho đến khi kết thúc lộ trình ngược.
\end{description}

\vspace{1em}
\noindent Đặc điểm:
\begin{itemize}
    \item Marsbot được lập trình để nhớ lại toàn bộ lịch sử các mã điều khiển và khoảng thời gian giữa các lần đổi mã.
    \item Nhờ đó, Marsbot có thể đảo ngược lại lộ trình để quay về điểm xuất phát.
\end{itemize}

Sau khi nhận mã điều khiển, Curiosity Marsbot sẽ không xử lý ngay, mà phải đợi lệnh kích hoạt mã từ
bàn phím Keyboard \& Display MMIO Simulator. Có 3 lệnh như vậy:

\begin{description}
    \item[Enter] Kết thúc nhập mã và yêu cầu Marsbot thực thi.
    \item[Delete] Xóa toàn bộ mã điều khiển đang nhập.
    \item[Space] Lặp lại lệnh đã thực hiện trước đó. Tiếp tục với yêu cầu này.
\end{description}

Hãy lập trình để Marsbot có thể hoạt động như đã mô tả.
Đồng thời bổ sung thêm tính năng: mỗi khi gửi một mã điều khiển cho Marsbot, hiển thị mã đó lên màn
hình console để người xem có thể giám sát lộ trình của xe.

\section{Định hướng cách làm}
\begin{enumerate}
    \item Khi người dùng nhập 1 ký tự vào Digital Lab Sim, tạo ra 1 ngắt để lưu ký tự vào bộ nhớ, tạo nên mã điều khiển.
    
    \item Kiểm tra xem ký tự được nhập trong KeyBoard and Display MMIO. Khi nhập ký tự enter, nếu có lỗi, chương trình sẽ in ra thông báo lỗi.
    
    \item Lần lượt kiểm tra xem mã điều khiển được nhập vào có trùng khớp với các đoạn mã đã quy định sẵn không. Nếu không, thông báo đoạn mã đó bị lỗi. Ngược lại, thực hiện theo thao tác đã quy định sẵn.

    \item Nếu mã được nhập vào là mã để rẽ trái (phải), lưu tọa độ x, y và góc
trước khi rẽ vào lần lượt 03 mảng số nguyên (x\_history, y\_history, a\_history) 

    \item In ra màn hình mã điều khiển đã nhập và xóa khỏi bộ nhớ. Nếu mã sai, in ra thông báo lỗi.
\end{enumerate}

\section*{MIPS Code Explanation}
\subsection{Dữ liệu}
\subsubsection{Giải thích}
Khai báo các giá trị cần sử dụng. 3 mảng số nguyên x\_history, y\_history, a\_history lần lượt lưu trữ các thông tin về x,y và góc alpha

\begin{lstlisting}[caption={MIPS Assembly Example}]
.data
	# mang luu tru thong tin vi tri x,y va goc a
	x_history:		.word 0 : 16	
	y_history:		.word 0 : 16	
	a_history:		.word 0 : 16    
	l_history:		.word 4		# history length

	a_current:		.word 0		# gia tri goc a khoi tao
	
	isGoing:		.word 0
	isTracking:		.word 0

	inputCode:		.space 8	# input command code
	code_history: 		.space 64 	# history code
	inputLength:			.word 0		# input command length

	GO_CODE:		.asciiz "1b4"	
	STOP_CODE:		.asciiz "c68"
	GOLEFT_CODE:		.asciiz "444"
	GORIGHT_CODE:	.asciiz "666"
	TRACK_CODE:		.asciiz "dad"
	UNTRACK_CODE:		.asciiz "cbc"
	REVERT:	.asciiz "999"
	WRONG_CODE:		.asciiz "Wrong control code"


\end{lstlisting}

\subsection{SetStartHeading}
\subsubsection{Giải thích}
Đây là hàm khởi tạo và cập nhật lịch sử các biến $x$, $y$ và $a$. Cụ thể, nó đặt $a$ thành 90, thực hiện một phép xoay thông qua hàm \texttt{ROTATE}, và cập nhật lịch sử
\begin{lstlisting}
    lw	$t7, l_history		# l_history += 4
    addi	$t7, $zero, 4		# luu thong tin x = 0; y = 0; a = 90
    sw	$t7, l_history
	
    li	$t7, 90
    sw	$t7, a_current	# goc a = 90 do
    jal	ROTATE
    nop
	
    sw	$t7, a_history + 4	# a_history[1] = 90
					# x_history[1] =0
					# y_history[1] = 0
    j	waitForKey

    
\end{lstlisting}

\subsection{Phần Loại Bỏ Mã}
\subsubsection{Giải thích}
Mục đích tổng thể của hàm này là để đặt lại bộ đệm \texttt{inputCode} bằng cách đặt mỗi byte thành \texttt{'\textbackslash 0'} và đặt lại \texttt{inputLength} về 0,đảm bảo rằng bộ đệm được xóa sạch để nhận đầu vào mới.
\begin{lstlisting}
resetInput:	
        jal	removeCode			
        nop		
removeCode:	
	addi	$sp, $sp, 4			# backup
	sw	$t1, 0($sp)
	addi	$sp, $sp, 4	
	sw	$t2, 0($sp)	
	addi	$sp, $sp, 4	
	sw	$s1, 0($sp)
	addi	$sp, $sp, 4
	sw	$t3, 0($sp)
	addi	$sp, $sp, 4	
	sw	$s2, 0($sp)
	
	lw	$t3, inputLength			# $t3 = inputLength
	addi	$t1, $zero, -1		# $t1 = -1 = i
	
removeCode_loop: 
	addi	$t1, $t1, 1			# i++	
	sb	$zero, inputCode($t1)		# inputCode[i] = '\0'			
	bne	$t1, $t3, removeCode_loop	# if $t1 <=3 resetInput loop
	nop
				
	sw	$zero, inputLength		# reset inputLength = 0
	
removeCode_end: 
	lw	$s2, 0($sp)			# restore backup
	addi	$sp, $sp, -4
	lw	$t3, 0($sp)
	addi	$sp, $sp, -4
	lw	$s1, 0($sp)
	addi	$sp, $sp, -4
	lw	$t2, 0($sp)
	addi	$sp, $sp, -4
	lw	$t1, 0($sp)
	addi	$sp, $sp, -4
	
	jr	$ra
    
\end{lstlisting}

\subsection{Phần lặp lại mã}
\subsubsection{Giải thích}
Mục đích tổng thể của hàm này là để lặp lại lệnh cuối cùng được nhập bởi người dùng khi phát hiện được phím cách. Nó thực hiện điều này bằng cách sao chép lệnh trước đó từ code\_history sang inputCode và cập nhật độ dài đầu vào tương ứng.
\begin{lstlisting}
repeat:#khi nguoi dung nhap Space se in ra cau lenh truoc do
    addi	$sp, $sp, 4 # back up
		sw	$t0, 0($sp)
		addi	$sp, $sp, 4
		sw	$t1, 0($sp)
		addi	$sp, $sp, 4
		sw	$t2, 0($sp)
		addi	$sp, $sp, 4
		sw	$t3, 0($sp)
		addi	$sp, $sp, 4
		sw	$s0, 0($sp)
		addi	$sp, $sp, 4
		sw	$s1, 0($sp)
		
		
		la $s0, code_history
		lb $t0,0($s0)
		beq $t0,$0,waitForKey
		nop
		beq $t0,$0,waitForKey
		li $t0,3 
		sb $t0, inputLength 
		la $s0, code_history
		la $s1, inputCode 
		li $t1,0
		
		
repeat_loop:	
		add $t2, $s0,$t1
		lb $t2,0($t2)
		add $t3, $s1,$t1
		sb $t2,0($t3)
		beq $t1,$t0,end_repeat_loop
		add $t1,$t1,1
		j repeat_loop
end_repeat_loop:
	lw	$s1, 0($sp)			# restore backup
	addi	$sp, $sp, -4
	lw	$s0, 0($sp)
	addi	$sp, $sp, -4
	lw	$t3, 0($sp)
	addi	$sp, $sp, -4
	lw	$t2, 0($sp)
	addi	$sp, $sp, -4
	lw	$t1, 0($sp)
	addi	$sp, $sp, -4
	lw	$t0, 0($sp)
	addi	$sp, $sp, -4
 	j CheckKeyCode

\end{lstlisting}

\subsection{Phần so sánh chuỗi}
\subsubsection{Giải thích}
Mục đích của hàm strcmp là để so sánh ba ký tự đầu tiên của chuỗi inputCode với ba ký tự đầu tiên của một chuỗi khác được trỏ tới bởi $s3$. Nếu chúng bằng nhau, hàm sẽ đặt $t0$ thành 1. Nếu chúng không bằng nhau, $t0$ sẽ vẫn giữ giá trị 0
\begin{lstlisting}
strcmp:	addi	$sp, $sp, 4			# back up
	sw	$t1, 0($sp)
	addi	$sp, $sp, 4
	sw	$s1, 0($sp)
	addi	$sp,$sp,4
	sw	$t2, 0($sp)
	addi	$sp, $sp, 4
	sw	$t3, 0($sp)
	
	li	$t0,0		# $t0  = 0
	li 	$t1,0		# $t1 = i = 0
	
strcmp_loop: 
	beq 	$t1, 3, strcmp_equal		# if i = 3 -> end loop -> equal
	nop
	
	lb	$t2, inputCode($t1)		# $t2 = inputCode[i]
			
	add	$t3, $s3, $t1		# $t3 = s + i
	lb	$t3, 0($t3)			# $t3 = s[i]
	
	beq	$t2, $t3, strcmp_next		# if $t2 == $t3 -> continue the loop
	nop
	
	j	strcmp_end

strcmp_next: 
	addi	$t1, $t1, 1 		# i++
	j	strcmp_loop

strcmp_equal: add	$t0, $zero, 1		# $t0 = 1

strcmp_end: lw	$t3, 0($sp)			# restore the backup
	addi	$sp, $sp, -4
	lw	$t2, 0($sp)
	addi	$sp, $sp, -4
	lw	$s1, 0($sp)
	addi	$sp, $sp, -4
	lw	$t1, 0($sp)
	addi	$sp, $sp, -4

	jr $ra

\end{lstlisting}
\subsection{Lưu trữ đường đi}
\subsubsection{Giải thích}
Mục đích của hàm là lưu trữ thông tin vị trí x,y và góc alpha mỗi lần robot di chuyển
\begin{lstlisting}
saveHistory:
	addi	$sp, $sp, 4			# backup
	sw	$t1, 0($sp)
	addi	$sp, $sp, 4
	sw	$t2, 0($sp)
	addi	$sp, $sp, 4
	sw	$t3, 0($sp)
	addi	$sp, $sp, 4
	sw	$t4, 0($sp)
	addi	$sp, $sp, 4
	sw	$s1, 0($sp)
	addi	$sp, $sp, 4
	sw	$s2, 0($sp)
	addi	$sp, $sp, 4
	sw	$s3, 0($sp)
	addi	$sp, $sp, 4
	sw	$s4, 0($sp)
	
	lw	$s1, WHEREX			# s1 = x	
	lw	$s2, WHEREY			# s2 = y
	lw	$s4, a_current		# s4 = a_current
	
	lw	$t3, l_history		# $t3 = l_history
	addi	$t3,$t3,4
	sw	$s1, x_history($t3)		# store: x, y, alpha
	sw	$s2, y_history($t3)
	sw	$s4, a_history($t3) 
	
	sw	$t3, l_history
	
	lw	$s4, 0($sp)			# restore backup
	addi	$sp, $sp, -4
	lw	$s3, 0($sp)
	addi	$sp, $sp, -4
	lw	$s2, 0($sp)
	addi	$sp, $sp, -4
	lw	$s1, 0($sp)
	addi	$sp, $sp, -4
	lw	$t4, 0($sp)
	addi	$sp, $sp, -4
	lw	$t3, 0($sp)
	addi	$sp, $sp, -4
	lw	$t2, 0($sp)
	addi	$sp, $sp, -4
	lw	$t1, 0($sp)
	addi	$sp, $sp, -4
	
saveHistory_end: jr	$ra		
\end{lstlisting}

\subsection{Save Code}
\subsubsection{Giải thích}
Lưu trữ thông tin của các input nhập vào, phù hợp để sau này thực hiện các hàm như repeat hay revert
\begin{lstlisting}
save_code:	addi	$sp, $sp, 4 # back up
		sw	$t0, 0($sp)
		addi	$sp, $sp, 4
		sw	$t1, 0($sp)
		addi	$sp, $sp, 4
		sw	$t2, 0($sp)
		addi	$sp, $sp, 4
		sw	$t3, 0($sp)
		addi	$sp, $sp, 4
		sw	$s0, 0($sp)
		addi	$sp, $sp, 4
		sw	$s1, 0($sp)
		
		
		
		la $t0,inputLength
		lw $t0,inputLength
		la $s0, inputCode
		la $s1, code_history
		li $t1,0		# i =0		
save_code_loop:
		add $t2, $s0,$t1
		lb $t2,0($t2) 		# $t2 = inputCode[i]
		add $t3, $s1,$t1
		sb $t2,0($t3) 		# code_history[i] = inputCode[i]
		beq $t1,$t0,end_save_code_loop
		add $t1,$t1,1
		j save_code_loop
end_save_code_loop:
	
	
	
	lw	$s1, 0($sp)			# restore backup
	addi	$sp, $sp, -4
	lw	$s0, 0($sp)
	addi	$sp, $sp, -4
	lw	$t3, 0($sp)
	addi	$sp, $sp, -4
	lw	$t2, 0($sp)
	addi	$sp, $sp, -4
	lw	$t1, 0($sp)
	addi	$sp, $sp, -4
	lw	$t0, 0($sp)
	addi	$sp, $sp, -4
 	jr $ra
\end{lstlisting}

\subsection{Check Key Code}
\subsubsection{Giải thích}
Kiểm tra mã điều khiển có hợp lệ về độ dài và khớp với một
trong các mã đã được quy ước
\begin{lstlisting}
CheckKeyCode:	
	lw	$s2, inputLength			# inputLength != 3 -> invalid code
	bne	$s2, 3, printErrorMsg
		
	la	$s3, GO_CODE
	jal	strcmp
	beq	$t0, 1, case_go
		
	la	$s3, STOP_CODE
	jal	strcmp
	beq	$t0, 1, case_stop
		
	la	$s3, GOLEFT_CODE
	jal	strcmp
	beq	$t0, 1, case_turnLeft
	
	la	$s3, GORIGHT_CODE
	jal	strcmp
	beq	$t0, 1, case_turnRight
	
	la	$s3, TRACK_CODE
	jal	strcmp
	beq	$t0, 1, case_track

	la	$s3, UNTRACK_CODE
	jal	strcmp
	beq	$t0, 1, case_untrack
	
	la	$s3, REVERT
	jal	strcmp
	beq	$t0, 1, goBackward
	nop
	
	j	printErrorMsg
	
	switch:
	case_go:	jal save_code	
			j	go
	case_stop:	jal save_code
			j	stop
	case_turnLeft:	jal save_code
			j	turnLeft
	case_turnRight:	jal save_code
			j	turnRight
	case_track:	jal save_code
			j	track
	case_untrack:	jal save_code
			j	untrack
	case_goBackWard:jal save_code
			j	goBackward
	default:
\end{lstlisting}



\section{Giải thích các hàm chức năng điều khiển}
\subsection*{GO, STOP}
\subsubsection{Giải thích}
Điều khiển robot chuyển động hoặc dừng lại bằng cách thay đổi giá trị logic cổng MOVING, set isGoing bằng 0 hoặc 1 tương ứng
\begin{lstlisting}
    GO: 	addi	$sp, $sp, 4			# backup
	sw	$at, 0($sp)
	addi	$sp, $sp, 4
	sw	$k0, 0($sp)

	li	$at, MOVING			# change MOVING port
 	addi	$k0, $zero, 1		# to logic 1,
	sb	$k0, 0($at)			# to start running
	
	li	$t7, 1			# isGoing = 0
	sw	$t7, isGoing		
		
	lw	$k0, 0($sp)			# restore back up
	addi	$sp, $sp, -4
	lw	$at, 0($sp)
	addi	$sp, $sp, -4
	
	jr	$ra
	
STOP: 	addi	$sp, $sp, 4			# backup
	sw	$at, 0($sp)
	
	li	$at, MOVING			# change MOVING port to 0
	sb	$zero, 0($at)		# to stop
	
	sw	$zero, isGoing		# isGoing = 0
	
	lw	$at, 0($sp)			# restore back up
	addi	$sp, $sp, -4
	
	jr $ra
	
\end{lstlisting}

\subsection*{turnRight, turnLeft}
\subsubsection{Giải thích}
\begin{itemize}
    \item Cả hai hàm đều đảm bảo rằng robot đã dừng lại và không được theo dõi.
    \item Sau đó, cập nhật hướng của robot dựa trên hướng quay.
    \item Sau khi cập nhật hướng,  ghi lại vị trí và hướng mới vào lịch sử.
    \item Cuối cùng, chúng tiếp tục theo dõi và di chuyển nếu chúng đã được kích hoạt trước đó
\end{itemize}
\begin{lstlisting}
turnRight:	
	lw	$t7, isGoing
	lw	$s0, isTracking
	
	jal	STOP
	nop
	jal	UNTRACK
	nop
	
	la	$s5, a_current
	lw	$s6, 0($s5)		# $s6 is heading at now
	addi	$s6, $s6, 90		# increase alpha by 90*
	sw	$s6, 0($s5)		# update a_current
	
	jal	saveHistory
	jal	ROTATE
	
	beqz	$s0, noTrack1
	nop
	jal	TRACK
	noTrack1:	nop
	
	beqz	$t7, noGo1
	nop
	jal	GO
	noGo1:	nop
	
	j	printCode	
	
#-----------------------------------------------------------	
turnLeft:	
	lw	$t7, isGoing
	lw	$s0, isTracking
	
	jal	STOP
	nop
	jal	UNTRACK
	nop

	la	$s5, a_current
	lw	$s6, 0($s5)		# $s6 is heading at now
	addi	$s6, $s6, -90		# decrease alpha by 90*
	sw	$s6, 0($s5)		# update a_current
	
	jal	saveHistory
	jal	ROTATE
	
	beqz	$s0, noTrack2
	nop
	jal	TRACK
	noTrack2:	nop
	
	beqz	$t7, noGo2
	nop
	jal	GO
	noGo2:	nop
	
	j	printCode	

\end{lstlisting}


\subsection*{TRACK, UNTRACK}
\subsubsection{Giải thích}
Để lại dấu hoặc tắt để lại dấu bằng cách thay đổi logic cổng LEAVETRACK 0 hoặc 1, set isTracking bằng 0 hoặc 1 tương ứng
\begin{lstlisting}
TRACK:	addi	$sp, $sp, 4			# backup
	sw	$at, 0($sp)
	addi	$sp, $sp, 4
	sw	$k0, 0($sp)

 	li	$at, LEAVETRACK		# change LEAVETRACK port
	addi	$k0, $zero,1		# to logic 1,
 	sb	$k0, 0($at)			# to start tracking
 	
 	addi	$s0, $zero, 1
 	sw	$s0, isTracking
 	
	lw	$k0, 0($sp)			# restore back up
	addi	$sp, $sp, -4
	lw	$at, 0($sp)
	addi	$sp, $sp, -4
	
	jr $ra
	
UNTRACK:	addi	$sp, $sp, 4		# backup
	sw	$at, 0($sp)
	
	li	$at, LEAVETRACK	# change LEAVETRACK port to 0
 	sb	$zero, 0($at)	# to stop drawing tail
 	
 	sw	$zero, isTracking
 	
	lw	$at, 0($sp)		# restore back up
	addi	$sp, $sp, -4
	
	jr	$ra

\end{lstlisting}

\subsection*{ROTATE}
\subsection{Giải thích}
Hàm ROTATE được dùng để cập nhật hướng của robot bằng cách lấy hướng hiện tại từ a\_current và lưu trữ nó vào cổng HEADING, cho phép robot thay đổi hướng di chuyển của mình
\begin{lstlisting}
    ROTATE:	addi	$sp, $sp, 4		# backup
	sw	$t1, 0($sp)
	addi	$sp, $sp, 4
	sw	$t2, 0($sp)
	addi	$sp, $sp, 4
	sw	$t3, 0($sp)
	
	li	$t1, HEADING	# change HEADING port
	la	$t2, a_current
	lw	$t3, 0($t2)		# $t3 is heading at now
 	sw	$t3, 0($t1)		# to rotate robot
 	
 	lw	$t3, 0($sp)		# restore back up
	addi	$sp, $sp, -4
	lw	$t2, 0($sp)
	addi	$sp, $sp, -4
	lw	$t1, 0($sp)
	addi	$sp, $sp, -4
	
	jr	$ra
	
\end{lstlisting}

\subsection*{GoBackward}
\subsubsection{Giải thích}
\begin{itemize}
    \item Hàm goBackward điều phối việc di chuyển ngược lại của robot đến một điểm quay trước đó được lưu trữ trong lịch sử.
    \item Hàm goBackward\_turn: Sau khi đi ngược lại, hàm tính toán hướng ngược lại của hướng của robot (a\_current) bằng cách lấy hướng cuối cùng từ lịch sử, cộng thêm 180 độ vào đó và cập nhật a\_current tương ứng. Sau đó, nó gọi hàm ROTATE để cập nhật hướng.
    \item goBackward\_toTurningPoint: Lấy các tọa độ x và y từ lịch sử để xác định điểm quay trước đó, và kiểm tra các tọa độ x và y hiện tại cho đến khi chúng khớp với các tọa độ của điểm quay trong lịch sử
    \item Nếu điểm quay đã được đạt tới (l\_history == 4), hàm sẽ kết thúc. Nếu không, nó giảm l\_history và gọi đệ quy goBackward\_turn để tiếp tục đi ngược lại cho đến khi đạt đến điểm quay.
    \item Một khi robot đạt đến điểm quay, nó sẽ gọi hàm STOP, đặt lại hướng hiện tại (a\_current) và gọi hàm ROTATE để căn chỉnh với hướng mới. Sau đó, nó đặt lại l\_history thành 4, cho biết rằng robot đã hoàn thành quá trình đi ngược lại đến điểm quay
\end{itemize}


\begin{lstlisting}
goBackward:	
	li	$t7, IN_ADDRESS_HEXA_KEYBOARD	# Disable interrupts when going backward
    	sb	$zero, 0($t7)

	lw	$s5, l_history			# $s5 = length history
	jal	UNTRACK
	jal	GO
	
goBackward_turn: 
	
	lw	$s6, a_history($s5)		# $s6 = a_history[l_history]
	addi	$s6, $s6, 180			# $s6 = the reverse direction of alpha
	sw	$s6, a_current
	jal	ROTATE
	nop
	
goBackward_toTurningPoint:
	lw	$t9, x_history($s5)		# $t9 = x_history[i]	
	get_x: 
	li	$t8, WHEREX		# $t8 = x_current
	lw	$t8, 0($t8)
	bne	$t8, $t9, get_x		# x_current == x_history[i]
	nop				# -> get y
	
	lw	$t9, y_history($s5)		# $t9 = y_history[i]
	get_Y: 
	li	$t8, WHEREY		# $t8 = y_current
	lw	$t8, 0($t8)
	bne	$t8, $t9, get_Y		# y_current == y_history[i]
	nop				# -> turn or end
	
	beq $s5, 4, goBackward_end	# l_history == 4
	nop				# -> end
	addi $s5, $s5, -4 		# l_history--
	j goBackward_turn		# else -> turn
	
goBackward_end: 
	jal	STOP
	sw	$zero, a_current		# update heading
	jal	ROTATE
	
	addi	$s5, $zero, 4
	sw	$s5, l_history		# reset l_history = 4
	
	j	printCode
	
\end{lstlisting}

\section{Kết quả}
Kết quả thu được sau khi chạy các dòng lệnh như sau: 
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{images/ma_code1.1.png}
    \caption{Dòng lệnh 1}
    \label{fig:1}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/kq1.1.png}
    \caption{Kết quả TH1}
    \label{fig:2}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{images/ma_code1.2.png}
    \caption{Dòng lệnh 2}
    \label{fig:3}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\textwidth]{images/ketqua1.2.png}
    \caption{Kết quả TH2}
    \label{fig:4}
\end{figure}


\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\textwidth]{images/ma_code.png}
    \caption{Dòng lệnh 3}
    \label{fig:5}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\textwidth]{images/kq.png}
    \caption{Kết quả TH3}
    \label{fig:6}
\end{figure}
